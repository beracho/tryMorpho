/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package morpho.msosecu.sdk.api;

import morpho.morphosmart.sdk.api.IMsoSecu;

public class MsoSecu implements MsoSecuConstants, IMsoSecu {
  public  int getHostCertif(java.util.ArrayList<Byte> hostCertificate) {
	return MsoSecuJNI.getHostCertif(hostCertificate);
}

  public  int genRandom(byte[] randomData) {
	return MsoSecuJNI.genRandom(randomData);
}

  public  int tunnelingInit1(byte[] tokenMso, byte[] msoCertificate, byte[] msoHash, byte[] hostHash, java.util.ArrayList<Byte> tokenHostMso) {
	return MsoSecuJNI.tunnelingInit1(tokenMso, msoCertificate, msoHash, hostHash, tokenHostMso);
}

  public  int tunnelingInit2(byte[] tokenMso) {
	return MsoSecuJNI.tunnelingInit2(tokenMso);
}

  public  int tripleDesSign(byte[] tripleDesDataToSign, java.util.ArrayList<Byte> tripleDesSignature) {
	return MsoSecuJNI.tripleDesSign(tripleDesDataToSign, tripleDesSignature);
}

  public  int tripleDesCrypt(byte[] tripleDesClearData, java.util.ArrayList<Byte> tripleDesCryptData) {
	return MsoSecuJNI.tripleDesCrypt(tripleDesClearData, tripleDesCryptData);
}

  public  int desCrypt(byte[] key, byte[] desClearData, java.util.ArrayList<Byte> desCryptData) {
	return MsoSecuJNI.desCrypt(key, desClearData, desCryptData);
}

  public  int tripleDesVerifSign(byte[] tripleDesDataToVerifSign, byte[] tripleDesDataSignature, boolean[] tripleDesSignVerifResult) {
	return MsoSecuJNI.tripleDesVerifSign(tripleDesDataToVerifSign, tripleDesDataSignature, tripleDesSignVerifResult);
}

  public  int tripleDesDecrypt(byte[] tripleDesCryptData, java.util.ArrayList<Byte> tripleDesClearData) {
	return MsoSecuJNI.tripleDesDecrypt(tripleDesCryptData, tripleDesClearData);
}

  public  int verifOfferedSecuritySignature(byte[] msoCertificate, byte[] signature, byte[] dataToVerifSign, int[] signVerifResult) {
	return MsoSecuJNI.verifOfferedSecuritySignature(msoCertificate, signature, dataToVerifSign, signVerifResult);
}

  public  int verifSignRSA(byte[] msoCertificate, byte[] signature, byte[] dataToVerifSign, int[] signVerifResult) {
	return MsoSecuJNI.verifSignRSA(msoCertificate, signature, dataToVerifSign, signVerifResult);
}

  public  int verifSignDSA(byte[] msoCertificate, byte[] signature, byte[] dataToVerifSign, int[] signVerifResult) {
	return MsoSecuJNI.verifSignDSA(msoCertificate, signature, dataToVerifSign, signVerifResult);
}

  public  int verifCertif(byte[] certificate, int[] certVerifResult) {
	return MsoSecuJNI.verifCertif(certificate, certVerifResult);
}

  public  int tripleDesCryptByKey(byte[] key, byte[] tripleDesClearData, java.util.ArrayList<Byte> tripleDesCryptDataByKey) {
	return MsoSecuJNI.tripleDesCryptByKey(key, tripleDesClearData, tripleDesCryptDataByKey);
}

  public  int rsaEncrypt(byte[] certificate, byte[] rsaClearData, java.util.ArrayList<Byte> rsaCryptData) {
	return MsoSecuJNI.rsaEncrypt(certificate, rsaClearData, rsaCryptData);
}

  public  int signRSA(byte[] key, byte[] rsaDataToSign, java.util.ArrayList<Byte> rsaSignature) {
	return MsoSecuJNI.signRSA(key, rsaDataToSign, rsaSignature);
}

  public  int encrypt3DesCbcNopad(byte[] key, byte[] tripleDesCbcNoPadClearData, int i_i_3desCbcNoPadClearDataLen, byte[] iv, byte[] tripleDesCbcNoPadCryptData) {
	return MsoSecuJNI.encrypt3DesCbcNopad(key, tripleDesCbcNoPadClearData, i_i_3desCbcNoPadClearDataLen, iv, tripleDesCbcNoPadCryptData);
}

  public  int setOpenSSLPath(String openSSLPath) {
	return MsoSecuJNI.setOpenSSLPath(openSSLPath);
}

  public  int encryptAes128Cbc(byte[] key, byte[] aes128CbcClearData, byte[] iv, boolean usePadding, java.util.ArrayList<Byte> aes128CbcCryptedData) {
	return MsoSecuJNI.encryptAes128Cbc(key, aes128CbcClearData, iv, usePadding, aes128CbcCryptedData);
}

  public  int decryptAes128Cbc(byte[] key, byte[] aes128CbcCryptedData, byte[] iv, boolean usePadding, java.util.ArrayList<Byte> aes128CbcClearData) {
	return MsoSecuJNI.decryptAes128Cbc(key, aes128CbcCryptedData, iv, usePadding, aes128CbcClearData);
}

  public  int computeCRC32(byte[] data, long polynomial, long initialCRCValue, boolean inputReflected, boolean outputReflected, long outputXOR, long[] crcValue) {
	return MsoSecuJNI.computeCRC32(data, polynomial, initialCRCValue, inputReflected, outputReflected, outputXOR, crcValue);
}

}
